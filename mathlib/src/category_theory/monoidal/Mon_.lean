/-
Copyright (c) 2020 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison
-/
import category_theory.monoidal.braided
import category_theory.monoidal.discrete
import category_theory.monoidal.coherence_lemmas
import category_theory.limits.shapes.terminal
import algebra.punit_instances

/-!
# The category of monoids in a monoidal category.

We define monoids in a monoidal category `C` and show that the category of monoids is equivalent to
the category of lax monoidal functors from the unit monoidal category to `C`.  We also show that if
`C` is braided, then the category of monoids is naturally monoidal.

-/

universes v‚ÇÅ v‚ÇÇ u‚ÇÅ u‚ÇÇ u

open category_theory
open category_theory.monoidal_category

variables (C : Type u‚ÇÅ) [category.{v‚ÇÅ} C] [monoidal_category.{v‚ÇÅ} C]

/--
A monoid object internal to a monoidal category.

When the monoidal category is preadditive, this is also sometimes called an "algebra object".
-/
structure Mon_ :=
(X : C)
(one : ùüô_ C ‚ü∂ X)
(mul : X ‚äó X ‚ü∂ X)
(one_mul' : (one ‚äó ùüô X) ‚â´ mul = (Œª_ X).hom . obviously)
(mul_one' : (ùüô X ‚äó one) ‚â´ mul = (œÅ_ X).hom . obviously)
-- Obviously there is some flexibility stating this axiom.
-- This one has left- and right-hand sides matching the statement of `monoid.mul_assoc`,
-- and chooses to place the associator on the right-hand side.
-- The heuristic is that unitors and associators "don't have much weight".
(mul_assoc' : (mul ‚äó ùüô X) ‚â´ mul = (Œ±_ X X X).hom ‚â´ (ùüô X ‚äó mul) ‚â´ mul . obviously)

restate_axiom Mon_.one_mul'
restate_axiom Mon_.mul_one'
restate_axiom Mon_.mul_assoc'
attribute [reassoc] Mon_.one_mul Mon_.mul_one -- We prove a more general `@[simp]` lemma below.
attribute [simp, reassoc] Mon_.mul_assoc

namespace Mon_

/--
The trivial monoid object. We later show this is initial in `Mon_ C`.
-/
@[simps]
def trivial : Mon_ C :=
{ X := ùüô_ C,
  one := ùüô _,
  mul := (Œª_ _).hom,
  mul_assoc' := by coherence,
  mul_one' := by coherence }

instance : inhabited (Mon_ C) := ‚ü®trivial C‚ü©

variables {C} {M : Mon_ C}

@[simp] lemma one_mul_hom {Z : C} (f : Z ‚ü∂ M.X) : (M.one ‚äó f) ‚â´ M.mul = (Œª_ Z).hom ‚â´ f :=
by rw [‚Üêid_tensor_comp_tensor_id, category.assoc, M.one_mul, left_unitor_naturality]

@[simp] lemma mul_one_hom {Z : C} (f : Z ‚ü∂ M.X) : (f ‚äó M.one) ‚â´ M.mul = (œÅ_ Z).hom ‚â´ f :=
by rw [‚Üêtensor_id_comp_id_tensor, category.assoc, M.mul_one, right_unitor_naturality]

lemma assoc_flip : (ùüô M.X ‚äó M.mul) ‚â´ M.mul = (Œ±_ M.X M.X M.X).inv ‚â´ (M.mul ‚äó ùüô M.X) ‚â´ M.mul :=
by simp

/-- A morphism of monoid objects. -/
@[ext]
structure hom (M N : Mon_ C) :=
(hom : M.X ‚ü∂ N.X)
(one_hom' : M.one ‚â´ hom = N.one . obviously)
(mul_hom' : M.mul ‚â´ hom = (hom ‚äó hom) ‚â´ N.mul . obviously)

restate_axiom hom.one_hom'
restate_axiom hom.mul_hom'
attribute [simp, reassoc] hom.one_hom hom.mul_hom

/-- The identity morphism on a monoid object. -/
@[simps]
def id (M : Mon_ C) : hom M M :=
{ hom := ùüô M.X, }

instance hom_inhabited (M : Mon_ C) : inhabited (hom M M) := ‚ü®id M‚ü©

/-- Composition of morphisms of monoid objects. -/
@[simps]
def comp {M N O : Mon_ C} (f : hom M N) (g : hom N O) : hom M O :=
{ hom := f.hom ‚â´ g.hom, }

instance : category (Mon_ C) :=
{ hom := Œª M N, hom M N,
  id := id,
  comp := Œª M N O f g, comp f g, }

@[simp] lemma id_hom' (M : Mon_ C) : (ùüô M : hom M M).hom = ùüô M.X := rfl
@[simp] lemma comp_hom' {M N K : Mon_ C} (f : M ‚ü∂ N) (g : N ‚ü∂ K) :
  (f ‚â´ g : hom M K).hom = f.hom ‚â´ g.hom := rfl

section
variables (C)

/-- The forgetful functor from monoid objects to the ambient category. -/
@[simps]
def forget : Mon_ C ‚•§ C :=
{ obj := Œª A, A.X,
  map := Œª A B f, f.hom, }

end

instance forget_faithful : faithful (@forget C _ _) := { }

instance {A B : Mon_ C} (f : A ‚ü∂ B) [e : is_iso ((forget C).map f)] : is_iso f.hom := e

/-- The forgetful functor from monoid objects to the ambient category reflects isomorphisms. -/
instance : reflects_isomorphisms (forget C) :=
{ reflects := Œª X Y f e, by exactI ‚ü®‚ü®
{ hom := inv f.hom,
  mul_hom' :=
  begin
    simp only [is_iso.comp_inv_eq, hom.mul_hom, category.assoc, ‚Üêtensor_comp_assoc,
      is_iso.inv_hom_id, tensor_id, category.id_comp],
  end }, by tidy‚ü©‚ü© }

/--
Construct an isomorphism of monoids by giving an isomorphism between the underlying objects
and checking compatibility with unit and multiplication only in the forward direction.
-/
def iso_of_iso {M N : Mon_ C}
  (f : M.X ‚âÖ N.X)
  (one_f : M.one ‚â´ f.hom = N.one)
  (mul_f : M.mul ‚â´ f.hom = (f.hom ‚äó f.hom) ‚â´ N.mul) :
  M ‚âÖ N :=
{ hom := { hom := f.hom, one_hom' := one_f, mul_hom' := mul_f },
  inv :=
  { hom := f.inv,
    one_hom' := by { rw ‚Üêone_f, simp },
    mul_hom' :=
    begin
      rw ‚Üê(cancel_mono f.hom),
      slice_rhs 2 3 { rw mul_f },
      simp,
    end } }

instance unique_hom_from_trivial (A : Mon_ C) : unique (trivial C ‚ü∂ A) :=
{ default :=
  { hom := A.one,
    one_hom' := by { dsimp, simp, },
    mul_hom' := by { dsimp, simp [A.one_mul, unitors_equal], } },
  uniq := Œª f,
  begin
    ext, simp,
    rw [‚Üêcategory.id_comp f.hom],
    erw f.one_hom,
  end }

open category_theory.limits

instance : has_initial (Mon_ C) :=
has_initial_of_unique (trivial C)

end Mon_

namespace category_theory.lax_monoidal_functor

variables {C} {D : Type u‚ÇÇ} [category.{v‚ÇÇ} D] [monoidal_category.{v‚ÇÇ} D]

/--
A lax monoidal functor takes monoid objects to monoid objects.

That is, a lax monoidal functor `F : C ‚•§ D` induces a functor `Mon_ C ‚•§ Mon_ D`.
-/
-- TODO: map_Mod F A : Mod A ‚•§ Mod (F.map_Mon A)
@[simps]
def map_Mon (F : lax_monoidal_functor C D) : Mon_ C ‚•§ Mon_ D :=
{ obj := Œª A,
  { X := F.obj A.X,
    one := F.Œµ ‚â´ F.map A.one,
    mul := F.Œº _ _ ‚â´ F.map A.mul,
    one_mul' :=
    begin
      conv_lhs { rw [comp_tensor_id, ‚ÜêF.to_functor.map_id], },
      slice_lhs 2 3 { rw [F.Œº_natural], },
      slice_lhs 3 4 { rw [‚ÜêF.to_functor.map_comp, A.one_mul], },
      rw [F.to_functor.map_id],
      rw [F.left_unitality],
    end,
    mul_one' :=
    begin
      conv_lhs { rw [id_tensor_comp, ‚ÜêF.to_functor.map_id], },
      slice_lhs 2 3 { rw [F.Œº_natural], },
      slice_lhs 3 4 { rw [‚ÜêF.to_functor.map_comp, A.mul_one], },
      rw [F.to_functor.map_id],
      rw [F.right_unitality],
    end,
    mul_assoc' :=
    begin
      conv_lhs { rw [comp_tensor_id, ‚ÜêF.to_functor.map_id], },
      slice_lhs 2 3 { rw [F.Œº_natural], },
      slice_lhs 3 4 { rw [‚ÜêF.to_functor.map_comp, A.mul_assoc], },
      conv_lhs { rw [F.to_functor.map_id] },
      conv_lhs { rw [F.to_functor.map_comp, F.to_functor.map_comp] },
      conv_rhs { rw [id_tensor_comp, ‚ÜêF.to_functor.map_id], },
      slice_rhs 3 4 { rw [F.Œº_natural], },
      conv_rhs { rw [F.to_functor.map_id] },
      slice_rhs 1 3 { rw [‚ÜêF.associativity], },
      simp only [category.assoc],
    end, },
  map := Œª A B f,
  { hom := F.map f.hom,
    one_hom' := by { dsimp, rw [category.assoc, ‚ÜêF.to_functor.map_comp, f.one_hom], },
    mul_hom' :=
    begin
      dsimp,
      rw [category.assoc, F.Œº_natural_assoc, ‚ÜêF.to_functor.map_comp, ‚ÜêF.to_functor.map_comp,
        f.mul_hom],
    end },
  map_id' := Œª A, by { ext, simp, },
  map_comp' := Œª A B C f g, by { ext, simp, }, }

variables (C D)

/-- `map_Mon` is functorial in the lax monoidal functor. -/
def map_Mon_functor : (lax_monoidal_functor C D) ‚•§ (Mon_ C ‚•§ Mon_ D) :=
{ obj := map_Mon,
  map := Œª F G Œ±,
  { app := Œª A,
    { hom := Œ±.app A.X, } } }

end category_theory.lax_monoidal_functor

namespace Mon_

open category_theory.lax_monoidal_functor

namespace equiv_lax_monoidal_functor_punit

/-- Implementation of `Mon_.equiv_lax_monoidal_functor_punit`. -/
@[simps]
def lax_monoidal_to_Mon : lax_monoidal_functor (discrete punit.{u+1}) C ‚•§ Mon_ C :=
{ obj := Œª F, (F.map_Mon : Mon_ _ ‚•§ Mon_ C).obj (trivial (discrete punit)),
  map := Œª F G Œ±, ((map_Mon_functor (discrete punit) C).map Œ±).app _ }

/-- Implementation of `Mon_.equiv_lax_monoidal_functor_punit`. -/
@[simps]
def Mon_to_lax_monoidal : Mon_ C ‚•§ lax_monoidal_functor (discrete punit.{u+1}) C :=
{ obj := Œª A,
  { obj := Œª _, A.X,
    map := Œª _ _ _, ùüô _,
    Œµ := A.one,
    Œº := Œª _ _, A.mul,
    map_id' := Œª _, rfl,
    map_comp' := Œª _ _ _ _ _, (category.id_comp (ùüô A.X)).symm, },
  map := Œª A B f,
  { app := Œª _, f.hom,
    naturality' := Œª _ _ _, by { dsimp, rw [category.id_comp, category.comp_id], },
    unit' := f.one_hom,
    tensor' := Œª _ _, f.mul_hom, }, }

/-- Implementation of `Mon_.equiv_lax_monoidal_functor_punit`. -/
@[simps]
def unit_iso :
  ùü≠ (lax_monoidal_functor (discrete punit.{u+1}) C) ‚âÖ
    lax_monoidal_to_Mon C ‚ãô Mon_to_lax_monoidal C :=
nat_iso.of_components (Œª F,
  monoidal_nat_iso.of_components
    (Œª _, F.to_functor.map_iso (eq_to_iso (by ext)))
    (by tidy) (by tidy) (by tidy))
  (by tidy)

/-- Implementation of `Mon_.equiv_lax_monoidal_functor_punit`. -/
@[simps]
def counit_iso : Mon_to_lax_monoidal C ‚ãô lax_monoidal_to_Mon C ‚âÖ ùü≠ (Mon_ C) :=
nat_iso.of_components (Œª F, { hom := { hom := ùüô _, }, inv := { hom := ùüô _, } })
  (by tidy)

end equiv_lax_monoidal_functor_punit

open equiv_lax_monoidal_functor_punit

/--
Monoid objects in `C` are "just" lax monoidal functors from the trivial monoidal category to `C`.
-/
@[simps]
def equiv_lax_monoidal_functor_punit : lax_monoidal_functor (discrete punit.{u+1}) C ‚âå Mon_ C :=
{ functor := lax_monoidal_to_Mon C,
  inverse := Mon_to_lax_monoidal C,
  unit_iso := unit_iso C,
  counit_iso := counit_iso C, }

end Mon_

namespace Mon_

/-!
In this section, we prove that the category of monoids in a braided monoidal category is monoidal.

Given two monoids `M` and `N` in a braided monoidal category `C`, the multiplication on the tensor
product `M.X ‚äó N.X` is defined in the obvious way: it is the tensor product of the multiplications
on `M` and `N`, except that the tensor factors in the source come in the wrong order, which we fix
by pre-composing with a permutation isomorphism constructed from the braiding.

A more conceptual way of understanding this definition is the following: The braiding on `C` gives
rise to a monoidal structure on the tensor product functor from `C √ó C` to `C`.  A pair of monoids
in `C` gives rise to a monoid in `C √ó C`, which the tensor product functor by being monoidal takes
to a monoid in `C`.  The permutation isomorphism appearing in the definition of the multiplication
on the tensor product of two monoids is an instance of a more general family of isomorphisms which
together form a strength that equips the tensor product functor with a monoidal structure, and the
monoid axioms for the tensor product follow from the monoid axioms for the tensor factors plus the
properties of the strength (i.e., monoidal functor axioms).  The strength `tensor_Œº` of the tensor
product functor has been defined in `category_theory.monoidal.braided`.  Its properties, stated as
independent lemmas in that module, are used extensively in the proofs below.  Notice that we could
have followed the above plan not only conceptually but also as a possible implementation and could
have constructed the tensor product of monoids via `map_Mon`, but we chose to give a more explicit
definition directly in terms of `tensor_Œº`.

To complete the definition of the monoidal category structure on the category of monoids, we need
to provide definitions of associator and unitors.  The obvious candidates are the associator and
unitors from `C`, but we need to prove that they are monoid morphisms, i.e., compatible with unit
and multiplication.  These properties translate to the monoidality of the associator and unitors
(with respect to the monoidal structures on the functors they relate), which have also been proved
in `category_theory.monoidal.braided`.

-/

variable {C}

-- The proofs that associators and unitors preserve monoid units don't require braiding.

lemma one_associator {M N P : Mon_ C} :
    ((Œª_ (ùüô_ C)).inv ‚â´ ((Œª_ (ùüô_ C)).inv ‚â´ (M.one ‚äó N.one) ‚äó P.one)) ‚â´ (Œ±_ M.X N.X P.X).hom
  = (Œª_ (ùüô_ C)).inv ‚â´ (M.one ‚äó (Œª_ (ùüô_ C)).inv ‚â´ (N.one ‚äó P.one)) :=
begin
  simp,
  slice_lhs 1 3 { rw [‚Üêcategory.id_comp P.one, tensor_comp] },
  slice_lhs 2 3 { rw associator_naturality },
  slice_rhs 1 2 { rw [‚Üêcategory.id_comp M.one, tensor_comp] },
  slice_lhs 1 2 { rw [‚Üêleft_unitor_tensor_inv] },
  rw ‚Üê(cancel_epi (Œª_ (ùüô_ C)).inv),
  slice_lhs 1 2 { rw [left_unitor_inv_naturality] },
  simp only [category.assoc],
end

lemma one_left_unitor {M : Mon_ C} :
  ((Œª_ (ùüô_ C)).inv ‚â´ (ùüô (ùüô_ C) ‚äó M.one)) ‚â´ (Œª_ M.X).hom = M.one :=
by { slice_lhs 2 3 { rw left_unitor_naturality }, simp }

lemma one_right_unitor {M : Mon_ C} :
  ((Œª_ (ùüô_ C)).inv ‚â´ (M.one ‚äó ùüô (ùüô_ C))) ‚â´ (œÅ_ M.X).hom = M.one :=
by { slice_lhs 2 3 { rw [right_unitor_naturality, ‚Üêunitors_equal] }, simp }

variable [braided_category C]

lemma Mon_tensor_one_mul (M N : Mon_ C) :
    ((Œª_ (ùüô_ C)).inv ‚â´ (M.one ‚äó N.one) ‚äó ùüô (M.X ‚äó N.X)) ‚â´
    tensor_Œº C (M.X, N.X) (M.X, N.X) ‚â´ (M.mul ‚äó N.mul)
  = (Œª_ (M.X ‚äó N.X)).hom :=
begin
  rw [‚Üêcategory.id_comp (ùüô (M.X ‚äó N.X)), tensor_comp],
  slice_lhs 2 3 { rw [‚Üêtensor_id, tensor_Œº_natural] },
  slice_lhs 3 4 { rw [‚Üêtensor_comp, one_mul M, one_mul N] },
  symmetry,
  exact tensor_left_unitality C M.X N.X,
end

lemma Mon_tensor_mul_one (M N : Mon_ C) :
    (ùüô (M.X ‚äó N.X) ‚äó (Œª_ (ùüô_ C)).inv ‚â´ (M.one ‚äó N.one)) ‚â´
    tensor_Œº C (M.X, N.X) (M.X, N.X) ‚â´ (M.mul ‚äó N.mul)
  = (œÅ_ (M.X ‚äó N.X)).hom :=
begin
  rw [‚Üêcategory.id_comp (ùüô (M.X ‚äó N.X)), tensor_comp],
  slice_lhs 2 3 { rw [‚Üêtensor_id, tensor_Œº_natural] },
  slice_lhs 3 4 { rw [‚Üêtensor_comp, mul_one M, mul_one N] },
  symmetry,
  exact tensor_right_unitality C M.X N.X,
end

lemma Mon_tensor_mul_assoc (M N : Mon_ C) :
    (tensor_Œº C (M.X, N.X) (M.X, N.X) ‚â´ (M.mul ‚äó N.mul) ‚äó ùüô (M.X ‚äó N.X)) ‚â´
    tensor_Œº C (M.X, N.X) (M.X, N.X) ‚â´
    (M.mul ‚äó N.mul)
  = (Œ±_ (M.X ‚äó N.X) (M.X ‚äó N.X) (M.X ‚äó N.X)).hom ‚â´
    (ùüô (M.X ‚äó N.X) ‚äó tensor_Œº C (M.X, N.X) (M.X, N.X) ‚â´ (M.mul ‚äó N.mul)) ‚â´
    tensor_Œº C (M.X, N.X) (M.X, N.X) ‚â´
    (M.mul ‚äó N.mul) :=
begin
  rw [‚Üêcategory.id_comp (ùüô (M.X ‚äó N.X)), tensor_comp],
  slice_lhs 2 3 { rw [‚Üêtensor_id, tensor_Œº_natural] },
  slice_lhs 3 4 { rw [‚Üêtensor_comp, mul_assoc M, mul_assoc N, tensor_comp, tensor_comp] },
  slice_lhs 1 3 { rw [tensor_associativity] },
  slice_lhs 3 4 { rw [‚Üêtensor_Œº_natural] },
  slice_lhs 2 3 { rw [‚Üêtensor_comp, tensor_id] },
  simp only [category.assoc],
end

lemma mul_associator {M N P : Mon_ C} :
    (tensor_Œº C (M.X ‚äó N.X, P.X) (M.X ‚äó N.X, P.X) ‚â´
      (tensor_Œº C (M.X, N.X) (M.X, N.X) ‚â´ (M.mul ‚äó N.mul) ‚äó P.mul)) ‚â´
    (Œ±_ M.X N.X P.X).hom
  = ((Œ±_ M.X N.X P.X).hom ‚äó (Œ±_ M.X N.X P.X).hom) ‚â´
    tensor_Œº C (M.X, N.X ‚äó P.X) (M.X, N.X ‚äó P.X) ‚â´
    (M.mul ‚äó tensor_Œº C (N.X, P.X) (N.X, P.X) ‚â´ (N.mul ‚äó P.mul)) :=
begin
  simp,
  slice_lhs 2 3 { rw [‚Üêcategory.id_comp P.mul, tensor_comp] },
  slice_lhs 3 4 { rw [associator_naturality] },
  slice_rhs 3 4 { rw [‚Üêcategory.id_comp M.mul, tensor_comp] },
  slice_lhs 1 3 { rw associator_monoidal },
  simp only [category.assoc],
end

lemma mul_left_unitor {M : Mon_ C}:
    (tensor_Œº C (ùüô_ C, M.X) (ùüô_ C, M.X) ‚â´ ((Œª_ (ùüô_ C)).hom ‚äó M.mul)) ‚â´ (Œª_ M.X).hom
  = ((Œª_ M.X).hom ‚äó (Œª_ M.X).hom) ‚â´ M.mul :=
begin
  rw [‚Üê(category.comp_id (Œª_ (ùüô_ C)).hom), ‚Üê(category.id_comp M.mul), tensor_comp],
  slice_lhs 3 4 { rw left_unitor_naturality },
  slice_lhs 1 3 { rw ‚Üêleft_unitor_monoidal },
  simp only [category.assoc, category.id_comp],
end

lemma mul_right_unitor {M : Mon_ C} :
    (tensor_Œº C (M.X, ùüô_ C) (M.X, ùüô_ C) ‚â´ (M.mul ‚äó (Œª_ (ùüô_ C)).hom)) ‚â´ (œÅ_ M.X).hom
  = ((œÅ_ M.X).hom ‚äó (œÅ_ M.X).hom) ‚â´ M.mul :=
begin
  rw [‚Üê(category.id_comp M.mul), ‚Üê(category.comp_id (Œª_ (ùüô_ C)).hom), tensor_comp],
  slice_lhs 3 4 { rw right_unitor_naturality },
  slice_lhs 1 3 { rw ‚Üêright_unitor_monoidal },
  simp only [category.assoc, category.id_comp],
end

instance Mon_monoidal : monoidal_category (Mon_ C) :=
{ tensor_obj := Œª M N,
  { X := M.X ‚äó N.X,
    one := (Œª_ (ùüô_ C)).inv ‚â´ (M.one ‚äó N.one),
    mul := tensor_Œº C (M.X, N.X) (M.X, N.X) ‚â´ (M.mul ‚äó N.mul),
    one_mul' := Mon_tensor_one_mul M N,
    mul_one' := Mon_tensor_mul_one M N,
    mul_assoc' := Mon_tensor_mul_assoc M N },
  tensor_hom := Œª M N P Q f g,
  { hom := f.hom ‚äó g.hom,
    one_hom' :=
    begin
      dsimp,
      slice_lhs 2 3 { rw [‚Üêtensor_comp, hom.one_hom f, hom.one_hom g] },
    end,
    mul_hom' :=
    begin
      dsimp,
      slice_rhs 1 2 { rw [tensor_Œº_natural] },
      slice_lhs 2 3 { rw [‚Üêtensor_comp, hom.mul_hom f, hom.mul_hom g, tensor_comp] },
      simp only [category.assoc],
    end },
  tensor_id' := by { intros, ext, apply tensor_id },
  tensor_comp' := by { intros, ext, apply tensor_comp },
  tensor_unit := trivial C,
  associator := Œª M N P, iso_of_iso (Œ±_ M.X N.X P.X) one_associator mul_associator,
  associator_naturality' := by { intros, ext, dsimp, apply associator_naturality },
  left_unitor := Œª M, iso_of_iso (Œª_ M.X) one_left_unitor mul_left_unitor,
  left_unitor_naturality' := by { intros, ext, dsimp, apply left_unitor_naturality },
  right_unitor := Œª M, iso_of_iso (œÅ_ M.X) one_right_unitor mul_right_unitor,
  right_unitor_naturality' := by { intros, ext, dsimp, apply right_unitor_naturality },
  pentagon' := by { intros, ext, dsimp, apply pentagon },
  triangle' := by { intros, ext, dsimp, apply triangle } }

end Mon_

/-!
Projects:
* Check that `Mon_ Mon ‚âå CommMon`, via the Eckmann-Hilton argument.
  (You'll have to hook up the cartesian monoidal structure on `Mon` first, available in #3463)
* Check that `Mon_ Top ‚âå [bundled topological monoids]`.
* Check that `Mon_ AddCommGroup ‚âå Ring`.
  (We've already got `Mon_ (Module R) ‚âå Algebra R`, in `category_theory.monoidal.internal.Module`.)
* Can you transport this monoidal structure to `Ring` or `Algebra R`?
  How does it compare to the "native" one?
* Show that when `C` is braided, the forgetful functor `Mon_ C ‚•§ C` is monoidal.
* Show that when `F` is a lax braided functor `C ‚•§ D`, the functor `map_Mon F : Mon_ C ‚•§ Mon_ D`
  is lax monoidal.
-/
